package go:http@0.2.0;

/// The `go:http/proxy` world implements a strict superset of `wasi:http/proxy`.
world proxy {
	import wasi:cli/environment@0.2.0;
	import wasi:random/random@0.2.0;
	import wasi:io/error@0.2.0;
	import wasi:io/poll@0.2.0;
	import wasi:io/streams@0.2.0;
	import wasi:cli/stdout@0.2.0;
	import wasi:cli/stderr@0.2.0;
	import wasi:cli/stdin@0.2.0;
	import wasi:clocks/monotonic-clock@0.2.0;
	import wasi:http/types@0.2.0;
	import wasi:http/outgoing-handler@0.2.0;
	import wasi:clocks/wall-clock@0.2.0;
	import wasi:filesystem/types@0.2.0;
	import wasi:filesystem/preopens@0.2.0;
	export wasi:http/incoming-handler@0.2.0;
}

package wasi:cli@0.2.0 {
	interface environment {
		/// Get the POSIX-style environment variables.
		///
		/// Each environment variable is provided as a pair of string variable names
		/// and string value.
		///
		/// Morally, these are a value import, but until value imports are available
		/// in the component model, this import function should return the same
		/// values each time it is called.
		get-environment: func() -> list<tuple<string, string>>;

		/// Get the POSIX-style arguments to the program.
		get-arguments: func() -> list<string>;

		/// Return a path that programs should use as their initial current working
		/// directory, interpreting `.` as shorthand for this.
		initial-cwd: func() -> option<string>;
	}

	interface stdin {
		use wasi:io/streams@0.2.0.{input-stream};
		get-stdin: func() -> input-stream;
	}

	interface stdout {
		use wasi:io/streams@0.2.0.{output-stream};
		get-stdout: func() -> output-stream;
	}

	interface stderr {
		use wasi:io/streams@0.2.0.{output-stream};
		get-stderr: func() -> output-stream;
	}
}

package wasi:filesystem@0.2.0 {
	/// WASI filesystem is a filesystem API primarily intended to let users run WASI
	/// programs that access their files on their existing filesystems, without
	/// significant overhead.
	///
	/// It is intended to be roughly portable between Unix-family platforms and
	/// Windows, though it does not hide many of the major differences.
	///
	/// Paths are passed as interface-type `string`s, meaning they must consist of
	/// a sequence of Unicode Scalar Values (USVs). Some filesystems may contain
	/// paths which are not accessible by this API.
	///
	/// The directory separator in WASI is always the forward-slash (`/`).
	///
	/// All paths in WASI are relative paths, and are interpreted relative to a
	/// `descriptor` referring to a base directory. If a `path` argument to any WASI
	/// function starts with `/`, or if any step of resolving a `path`, including
	/// `..` and symbolic link steps, reaches a directory outside of the base
	/// directory, or reaches a symlink to an absolute or rooted path in the
	/// underlying filesystem, the function fails with `error-code::not-permitted`.
	///
	/// For more information about WASI path resolution and sandboxing, see
	/// [WASI filesystem path resolution].
	///
	/// [WASI filesystem path resolution]: https://github.com/WebAssembly/wasi-filesystem/blob/main/path-resolution.md
	interface types {
		use wasi:io/streams@0.2.0.{input-stream};
		use wasi:io/streams@0.2.0.{output-stream};
		use wasi:io/streams@0.2.0.{error};
		use wasi:clocks/wall-clock@0.2.0.{datetime};

		/// File size or length of a region within a file.
		type filesize = u64;

		/// The type of a filesystem object referenced by a descriptor.
		///
		/// Note: This was called `filetype` in earlier versions of WASI.
		enum descriptor-type {
			/// The type of the descriptor or file is unknown or is different from
			/// any of the other types specified.
			unknown,
			/// The descriptor refers to a block device inode.
			block-device,
			/// The descriptor refers to a character device inode.
			character-device,
			/// The descriptor refers to a directory inode.
			directory,
			/// The descriptor refers to a named pipe.
			fifo,
			/// The file refers to a symbolic link inode.
			symbolic-link,
			/// The descriptor refers to a regular file inode.
			regular-file,
			/// The descriptor refers to a socket.
			socket
		}

		/// Descriptor flags.
		///
		/// Note: This was called `fdflags` in earlier versions of WASI.
		flags descriptor-flags {
			/// Read mode: Data can be read.
			read,
			/// Write mode: Data can be written to.
			write,
			/// Request that writes be performed according to synchronized I/O file
			/// integrity completion. The data stored in the file and the file's
			/// metadata are synchronized. This is similar to `O_SYNC` in POSIX.
			///
			/// The precise semantics of this operation have not yet been defined for
			/// WASI. At this time, it should be interpreted as a request, and not a
			/// requirement.
			file-integrity-sync,
			/// Request that writes be performed according to synchronized I/O data
			/// integrity completion. Only the data stored in the file is
			/// synchronized. This is similar to `O_DSYNC` in POSIX.
			///
			/// The precise semantics of this operation have not yet been defined for
			/// WASI. At this time, it should be interpreted as a request, and not a
			/// requirement.
			data-integrity-sync,
			/// Requests that reads be performed at the same level of integrety
			/// requested for writes. This is similar to `O_RSYNC` in POSIX.
			///
			/// The precise semantics of this operation have not yet been defined for
			/// WASI. At this time, it should be interpreted as a request, and not a
			/// requirement.
			requested-write-sync,
			/// Mutating directories mode: Directory contents may be mutated.
			///
			/// When this flag is unset on a descriptor, operations using the
			/// descriptor which would create, rename, delete, modify the data or
			/// metadata of filesystem objects, or obtain another handle which
			/// would permit any of those, shall fail with `error-code::read-only` if
			/// they would otherwise succeed.
			///
			/// This may only be set on directories.
			mutate-directory,
		}

		/// Flags determining the method of how paths are resolved.
		flags path-flags {
			/// As long as the resolved path corresponds to a symbolic link, it is
			/// expanded.
			symlink-follow,
		}

		/// Open flags used by `open-at`.
		flags open-flags {
			/// Create file if it does not exist, similar to `O_CREAT` in POSIX.
			create,
			/// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.
			directory,
			/// Fail if file already exists, similar to `O_EXCL` in POSIX.
			exclusive,
			/// Truncate file to size 0, similar to `O_TRUNC` in POSIX.
			truncate,
		}

		/// Number of hard links to an inode.
		type link-count = u64;

		/// File attributes.
		///
		/// Note: This was called `filestat` in earlier versions of WASI.
		record descriptor-stat {
			/// File type.
			%type: descriptor-type,
			/// Number of hard links to the file.
			link-count: link-count,
			/// For regular files, the file size in bytes. For symbolic links, the
			/// length in bytes of the pathname contained in the symbolic link.
			size: filesize,
			/// Last data access timestamp.
			///
			/// If the `option` is none, the platform doesn't maintain an access
			/// timestamp for this file.
			data-access-timestamp: option<datetime>,
			/// Last data modification timestamp.
			///
			/// If the `option` is none, the platform doesn't maintain a
			/// modification timestamp for this file.
			data-modification-timestamp: option<datetime>,
			/// Last file status-change timestamp.
			///
			/// If the `option` is none, the platform doesn't maintain a
			/// status-change timestamp for this file.
			status-change-timestamp: option<datetime>,
		}

		/// When setting a timestamp, this gives the value to set it to.
		variant new-timestamp {
			/// Leave the timestamp set to its previous value.
			no-change,
			/// Set the timestamp to the current time of the system clock associated
			/// with the filesystem.
			now,
			/// Set the timestamp to the given value.
			timestamp(datetime),
		}

		/// A directory entry.
		record directory-entry {
			/// The type of the file referred to by this directory entry.
			%type: descriptor-type,
			/// The name of the object.
			name: string,
		}

		/// Error codes returned by functions, similar to `errno` in POSIX.
		/// Not all of these error codes are returned by the functions provided by this
		/// API; some are used in higher-level library layers, and others are provided
		/// merely for alignment with POSIX.
		enum error-code {
			/// Permission denied, similar to `EACCES` in POSIX.
			access,
			/// Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK`
			/// in POSIX.
			would-block,
			/// Connection already in progress, similar to `EALREADY` in POSIX.
			already,
			/// Bad descriptor, similar to `EBADF` in POSIX.
			bad-descriptor,
			/// Device or resource busy, similar to `EBUSY` in POSIX.
			busy,
			/// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
			deadlock,
			/// Storage quota exceeded, similar to `EDQUOT` in POSIX.
			quota,
			/// File exists, similar to `EEXIST` in POSIX.
			exist,
			/// File too large, similar to `EFBIG` in POSIX.
			file-too-large,
			/// Illegal byte sequence, similar to `EILSEQ` in POSIX.
			illegal-byte-sequence,
			/// Operation in progress, similar to `EINPROGRESS` in POSIX.
			in-progress,
			/// Interrupted function, similar to `EINTR` in POSIX.
			interrupted,
			/// Invalid argument, similar to `EINVAL` in POSIX.
			invalid,
			/// I/O error, similar to `EIO` in POSIX.
			io,
			/// Is a directory, similar to `EISDIR` in POSIX.
			is-directory,
			/// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
			loop,
			/// Too many links, similar to `EMLINK` in POSIX.
			too-many-links,
			/// Message too large, similar to `EMSGSIZE` in POSIX.
			message-size,
			/// Filename too long, similar to `ENAMETOOLONG` in POSIX.
			name-too-long,
			/// No such device, similar to `ENODEV` in POSIX.
			no-device,
			/// No such file or directory, similar to `ENOENT` in POSIX.
			no-entry,
			/// No locks available, similar to `ENOLCK` in POSIX.
			no-lock,
			/// Not enough space, similar to `ENOMEM` in POSIX.
			insufficient-memory,
			/// No space left on device, similar to `ENOSPC` in POSIX.
			insufficient-space,
			/// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
			not-directory,
			/// Directory not empty, similar to `ENOTEMPTY` in POSIX.
			not-empty,
			/// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
			not-recoverable,
			/// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
			unsupported,
			/// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
			no-tty,
			/// No such device or address, similar to `ENXIO` in POSIX.
			no-such-device,
			/// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
			overflow,
			/// Operation not permitted, similar to `EPERM` in POSIX.
			not-permitted,
			/// Broken pipe, similar to `EPIPE` in POSIX.
			pipe,
			/// Read-only file system, similar to `EROFS` in POSIX.
			read-only,
			/// Invalid seek, similar to `ESPIPE` in POSIX.
			invalid-seek,
			/// Text file busy, similar to `ETXTBSY` in POSIX.
			text-file-busy,
			/// Cross-device link, similar to `EXDEV` in POSIX.
			cross-device
		}

		/// File or memory access pattern advisory information.
		enum advice {
			/// The application has no advice to give on its behavior with respect
			/// to the specified data.
			normal,
			/// The application expects to access the specified data sequentially
			/// from lower offsets to higher offsets.
			sequential,
			/// The application expects to access the specified data in a random
			/// order.
			random,
			/// The application expects to access the specified data in the near
			/// future.
			will-need,
			/// The application expects that it will not access the specified data
			/// in the near future.
			dont-need,
			/// The application expects to access the specified data once and then
			/// not reuse it thereafter.
			no-reuse
		}

		/// A 128-bit hash value, split into parts because wasm doesn't have a
		/// 128-bit integer type.
		record metadata-hash-value {
			/// 64 bits of a 128-bit hash value.
			lower: u64,
			/// Another 64 bits of a 128-bit hash value.
			upper: u64,
		}

		/// A descriptor is a reference to a filesystem object, which may be a file,
		/// directory, named pipe, special file, or other object on which filesystem
		/// calls may be made.
		resource descriptor {

			/// Provide file advisory information on a descriptor.
			///
			/// This is similar to `posix_fadvise` in POSIX.
			advise: func(offset: filesize, length: filesize, advice: advice) -> result<_, error-code>;

			/// Return a stream for appending to a file, if available.
			///
			/// May fail with an error-code describing why the file cannot be appended.
			///
			/// Note: This allows using `write-stream`, which is similar to `write` with
			/// `O_APPEND` in in POSIX.
			append-via-stream: func() -> result<output-stream, error-code>;

			/// Create a directory.
			///
			/// Note: This is similar to `mkdirat` in POSIX.
			create-directory-at: func(path: string) -> result<_, error-code>;

			/// Get flags associated with a descriptor.
			///
			/// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
			///
			/// Note: This returns the value that was the `fs_flags` value returned
			/// from `fdstat_get` in earlier versions of WASI.
			get-flags: func() -> result<descriptor-flags, error-code>;

			/// Get the dynamic type of a descriptor.
			///
			/// Note: This returns the same value as the `type` field of the `fd-stat`
			/// returned by `stat`, `stat-at` and similar.
			///
			/// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
			/// by `fstat` in POSIX.
			///
			/// Note: This returns the value that was the `fs_filetype` value returned
			/// from `fdstat_get` in earlier versions of WASI.
			get-type: func() -> result<descriptor-type, error-code>;

			/// Test whether two descriptors refer to the same filesystem object.
			///
			/// In POSIX, this corresponds to testing whether the two descriptors have the
			/// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
			/// wasi-filesystem does not expose device and inode numbers, so this function
			/// may be used instead.
			is-same-object: func(other: borrow<descriptor>) -> bool;

			/// Create a hard link.
			///
			/// Note: This is similar to `linkat` in POSIX.
			link-at: func(old-path-flags: path-flags, old-path: string, new-descriptor: borrow<descriptor>, new-path: string) -> result<_, error-code>;

			/// Return a hash of the metadata associated with a filesystem object referred
			/// to by a descriptor.
			///
			/// This returns a hash of the last-modification timestamp and file size, and
			/// may also include the inode number, device number, birth timestamp, and
			/// other metadata fields that may change when the file is modified or
			/// replaced. It may also include a secret value chosen by the
			/// implementation and not otherwise exposed.
			///
			/// Implementations are encourated to provide the following properties:
			///
			/// - If the file is not modified or replaced, the computed hash value should
			/// usually not change.
			/// - If the object is modified or replaced, the computed hash value should
			/// usually change.
			/// - The inputs to the hash should not be easily computable from the
			/// computed hash.
			///
			/// However, none of these is required.
			metadata-hash: func() -> result<metadata-hash-value, error-code>;

			/// Return a hash of the metadata associated with a filesystem object referred
			/// to by a directory descriptor and a relative path.
			///
			/// This performs the same hash computation as `metadata-hash`.
			metadata-hash-at: func(path-flags: path-flags, path: string) -> result<metadata-hash-value, error-code>;

			/// Open a file or directory.
			///
			/// The returned descriptor is not guaranteed to be the lowest-numbered
			/// descriptor not currently open/ it is randomized to prevent applications
			/// from depending on making assumptions about indexes, since this is
			/// error-prone in multi-threaded contexts. The returned descriptor is
			/// guaranteed to be less than 2**31.
			///
			/// If `flags` contains `descriptor-flags::mutate-directory`, and the base
			/// descriptor doesn't have `descriptor-flags::mutate-directory` set,
			/// `open-at` fails with `error-code::read-only`.
			///
			/// If `flags` contains `write` or `mutate-directory`, or `open-flags`
			/// contains `truncate` or `create`, and the base descriptor doesn't have
			/// `descriptor-flags::mutate-directory` set, `open-at` fails with
			/// `error-code::read-only`.
			///
			/// Note: This is similar to `openat` in POSIX.
			open-at: func(path-flags: path-flags, path: string, open-flags: open-flags, %flags: descriptor-flags) -> result<descriptor, error-code>;

			/// Read from a descriptor, without using and updating the descriptor's offset.
			///
			/// This function returns a list of bytes containing the data that was
			/// read, along with a bool which, when true, indicates that the end of the
			/// file was reached. The returned list will contain up to `length` bytes; it
			/// may return fewer than requested, if the end of the file is reached or
			/// if the I/O operation is interrupted.
			///
			/// In the future, this may change to return a `stream<u8, error-code>`.
			///
			/// Note: This is similar to `pread` in POSIX.
			read: func(length: filesize, offset: filesize) -> result<tuple<list<u8>, bool>, error-code>;

			/// Read directory entries from a directory.
			///
			/// On filesystems where directories contain entries referring to themselves
			/// and their parents, often named `.` and `..` respectively, these entries
			/// are omitted.
			///
			/// This always returns a new stream which starts at the beginning of the
			/// directory. Multiple streams may be active on the same directory, and they
			/// do not interfere with each other.
			read-directory: func() -> result<directory-entry-stream, error-code>;

			/// Return a stream for reading from a file, if available.
			///
			/// May fail with an error-code describing why the file cannot be read.
			///
			/// Multiple read, write, and append streams may be active on the same open
			/// file and they do not interfere with each other.
			///
			/// Note: This allows using `read-stream`, which is similar to `read` in POSIX.
			read-via-stream: func(offset: filesize) -> result<input-stream, error-code>;

			/// Read the contents of a symbolic link.
			///
			/// If the contents contain an absolute or rooted path in the underlying
			/// filesystem, this function fails with `error-code::not-permitted`.
			///
			/// Note: This is similar to `readlinkat` in POSIX.
			readlink-at: func(path: string) -> result<string, error-code>;

			/// Remove a directory.
			///
			/// Return `error-code::not-empty` if the directory is not empty.
			///
			/// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
			remove-directory-at: func(path: string) -> result<_, error-code>;

			/// Rename a filesystem object.
			///
			/// Note: This is similar to `renameat` in POSIX.
			rename-at: func(old-path: string, new-descriptor: borrow<descriptor>, new-path: string) -> result<_, error-code>;

			/// Adjust the size of an open file. If this increases the file's size, the
			/// extra bytes are filled with zeros.
			///
			/// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
			set-size: func(size: filesize) -> result<_, error-code>;

			/// Adjust the timestamps of an open file or directory.
			///
			/// Note: This is similar to `futimens` in POSIX.
			///
			/// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
			set-times: func(data-access-timestamp: new-timestamp, data-modification-timestamp: new-timestamp) -> result<_, error-code>;

			/// Adjust the timestamps of a file or directory.
			///
			/// Note: This is similar to `utimensat` in POSIX.
			///
			/// Note: This was called `path_filestat_set_times` in earlier versions of
			/// WASI.
			set-times-at: func(path-flags: path-flags, path: string, data-access-timestamp: new-timestamp, data-modification-timestamp: new-timestamp) -> result<_, error-code>;

			/// Return the attributes of an open file or directory.
			///
			/// Note: This is similar to `fstat` in POSIX, except that it does not return
			/// device and inode information. For testing whether two descriptors refer to
			/// the same underlying filesystem object, use `is-same-object`. To obtain
			/// additional data that can be used do determine whether a file has been
			/// modified, use `metadata-hash`.
			///
			/// Note: This was called `fd_filestat_get` in earlier versions of WASI.
			stat: func() -> result<descriptor-stat, error-code>;

			/// Return the attributes of a file or directory.
			///
			/// Note: This is similar to `fstatat` in POSIX, except that it does not
			/// return device and inode information. See the `stat` description for a
			/// discussion of alternatives.
			///
			/// Note: This was called `path_filestat_get` in earlier versions of WASI.
			stat-at: func(path-flags: path-flags, path: string) -> result<descriptor-stat, error-code>;

			/// Create a symbolic link (also known as a "symlink").
			///
			/// If `old-path` starts with `/`, the function fails with
			/// `error-code::not-permitted`.
			///
			/// Note: This is similar to `symlinkat` in POSIX.
			symlink-at: func(old-path: string, new-path: string) -> result<_, error-code>;

			/// Synchronize the data and metadata of a file to disk.
			///
			/// This function succeeds with no effect if the file descriptor is not
			/// opened for writing.
			///
			/// Note: This is similar to `fsync` in POSIX.
			sync: func() -> result<_, error-code>;

			/// Synchronize the data of a file to disk.
			///
			/// This function succeeds with no effect if the file descriptor is not
			/// opened for writing.
			///
			/// Note: This is similar to `fdatasync` in POSIX.
			sync-data: func() -> result<_, error-code>;

			/// Unlink a filesystem object that is not a directory.
			///
			/// Return `error-code::is-directory` if the path refers to a directory.
			/// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
			unlink-file-at: func(path: string) -> result<_, error-code>;

			/// Write to a descriptor, without using and updating the descriptor's offset.
			///
			/// It is valid to write past the end of a file; the file is extended to the
			/// extent of the write, with bytes between the previous end and the start of
			/// the write set to zero.
			///
			/// In the future, this may change to take a `stream<u8, error-code>`.
			///
			/// Note: This is similar to `pwrite` in POSIX.
			write: func(buffer: list<u8>, offset: filesize) -> result<filesize, error-code>;

			/// Return a stream for writing to a file, if available.
			///
			/// May fail with an error-code describing why the file cannot be written.
			///
			/// Note: This allows using `write-stream`, which is similar to `write` in
			/// POSIX.
			write-via-stream: func(offset: filesize) -> result<output-stream, error-code>;
		}

		/// A stream of directory entries.
		resource directory-entry-stream {

			/// Read a single directory entry from a `directory-entry-stream`.
			read-directory-entry: func() -> result<option<directory-entry>, error-code>;
		}

		/// Attempts to extract a filesystem-related `error-code` from the stream
		/// `error` provided.
		///
		/// Stream operations which return `stream-error::last-operation-failed`
		/// have a payload with more information about the operation that failed.
		/// This payload can be passed through to this function to see if there's
		/// filesystem-related information about the error to return.
		///
		/// Note that this function is fallible because not all stream-related
		/// errors are filesystem-related errors.
		filesystem-error-code: func(err: borrow<error>) -> option<error-code>;
	}

	interface preopens {
		use types.{descriptor};

		/// Return the set of preopened directories, and their path.
		get-directories: func() -> list<tuple<descriptor, string>>;
	}
}

package wasi:http@0.2.0 {
	/// This interface defines all of the types and methods for implementing
	/// HTTP Requests and Responses, both incoming and outgoing, as well as
	/// their headers, trailers, and bodies.
	interface types {
		use wasi:clocks/monotonic-clock@0.2.0.{duration};
		use wasi:io/streams@0.2.0.{input-stream};
		use wasi:io/streams@0.2.0.{output-stream};
		use wasi:io/error@0.2.0.{error as io-error};
		use wasi:io/poll@0.2.0.{pollable};

		/// This type corresponds to HTTP standard Methods.
		variant method {
			get,
			head,
			post,
			put,
			delete,
			connect,
			options,
			trace,
			patch,
			other(string),
		}

		/// This type corresponds to HTTP standard Related Schemes.
		variant scheme { HTTP, HTTPS, other(string) }

		/// Defines the case payload type for `DNS-error` above:
		record DNS-error-payload {
			rcode: option<string>,
			info-code: option<u16>,
		}

		/// Defines the case payload type for `TLS-alert-received` above:
		record TLS-alert-received-payload {
			alert-id: option<u8>,
			alert-message: option<string>,
		}

		/// Defines the case payload type for `HTTP-response-{header,trailer}-size` above:
		record field-size-payload {
			field-name: option<string>,
			field-size: option<u32>,
		}

		/// These cases are inspired by the IANA HTTP Proxy Error Types:
		/// https://www.iana.org/assignments/http-proxy-status/http-proxy-status.xhtml#table-http-proxy-error-types
		variant error-code {
			DNS-timeout,
			DNS-error(DNS-error-payload),
			destination-not-found,
			destination-unavailable,
			destination-IP-prohibited,
			destination-IP-unroutable,
			connection-refused,
			connection-terminated,
			connection-timeout,
			connection-read-timeout,
			connection-write-timeout,
			connection-limit-reached,
			TLS-protocol-error,
			TLS-certificate-error,
			TLS-alert-received(TLS-alert-received-payload),
			HTTP-request-denied,
			HTTP-request-length-required,
			HTTP-request-body-size(option<u64>),
			HTTP-request-method-invalid,
			HTTP-request-URI-invalid,
			HTTP-request-URI-too-long,
			HTTP-request-header-section-size(option<u32>),
			HTTP-request-header-size(option<field-size-payload>),
			HTTP-request-trailer-section-size(option<u32>),
			HTTP-request-trailer-size(field-size-payload),
			HTTP-response-incomplete,
			HTTP-response-header-section-size(option<u32>),
			HTTP-response-header-size(field-size-payload),
			HTTP-response-body-size(option<u64>),
			HTTP-response-trailer-section-size(option<u32>),
			HTTP-response-trailer-size(field-size-payload),
			HTTP-response-transfer-coding(option<string>),
			HTTP-response-content-coding(option<string>),
			HTTP-response-timeout,
			HTTP-upgrade-failed,
			HTTP-protocol-error,
			loop-detected,
			configuration-error,
			/// This is a catch-all error for anything that doesn't fit cleanly into a
			/// more specific case. It also includes an optional string for an
			/// unstructured description of the error. Users should not depend on the
			/// string for diagnosing errors, as it's not required to be consistent
			/// between implementations.
			internal-error(option<string>),
		}

		/// This type enumerates the different kinds of errors that may occur when
		/// setting or appending to a `fields` resource.
		variant header-error {
			/// This error indicates that a `field-key` or `field-value` was
			/// syntactically invalid when used with an operation that sets headers in a
			/// `fields`.
			invalid-syntax,
			/// This error indicates that a forbidden `field-key` was used when trying
			/// to set a header in a `fields`.
			forbidden,
			/// This error indicates that the operation on the `fields` was not
			/// permitted because the fields are immutable.
			immutable,
		}

		/// Field keys are always strings.
		type field-key = string;

		/// Field values should always be ASCII strings. However, in
		/// reality, HTTP implementations often have to interpret malformed values,
		/// so they are provided as a list of bytes.
		type field-value = list<u8>;

		/// This following block defines the `fields` resource which corresponds to
		/// HTTP standard Fields. Fields are a common representation used for both
		/// Headers and Trailers.
		///
		/// A `fields` may be mutable or immutable. A `fields` created using the
		/// constructor, `from-list`, or `clone` will be mutable, but a `fields`
		/// resource given by other means (including, but not limited to,
		/// `incoming-request.headers`, `outgoing-request.headers`) might be be
		/// immutable. In an immutable fields, the `set`, `append`, and `delete`
		/// operations will fail with `header-error.immutable`.
		resource fields {
			/// Construct an empty HTTP Fields.
			///
			/// The resulting `fields` is mutable.
			constructor();

			/// Append a value for a key. Does not change or delete any existing
			/// values for that key.
			///
			/// Fails with `header-error.immutable` if the `fields` are immutable.
			append: func(name: field-key, value: field-value) -> result<_, header-error>;

			/// Make a deep copy of the Fields. Equivelant in behavior to calling the
			/// `fields` constructor on the return value of `entries`. The resulting
			/// `fields` is mutable.
			clone: func() -> fields;

			/// Delete all values for a key. Does nothing if no values for the key
			/// exist.
			///
			/// Fails with `header-error.immutable` if the `fields` are immutable.
			delete: func(name: field-key) -> result<_, header-error>;

			/// Retrieve the full set of keys and values in the Fields. Like the
			/// constructor, the list represents each key-value pair.
			///
			/// The outer list represents each key-value pair in the Fields. Keys
			/// which have multiple values are represented by multiple entries in this
			/// list with the same key.
			entries: func() -> list<tuple<field-key, field-value>>;

			/// Get all of the values corresponding to a key. If the key is not present
			/// in this `fields`, an empty list is returned. However, if the key is
			/// present but empty, this is represented by a list with one or more
			/// empty field-values present.
			get: func(name: field-key) -> list<field-value>;

			/// Returns `true` when the key is present in this `fields`. If the key is
			/// syntactically invalid, `false` is returned.
			has: func(name: field-key) -> bool;

			/// Set all of the values for a key. Clears any existing values for that
			/// key, if they have been set.
			///
			/// Fails with `header-error.immutable` if the `fields` are immutable.
			set: func(name: field-key, value: list<field-value>) -> result<_, header-error>;

			/// Construct an HTTP Fields.
			///
			/// The resulting `fields` is mutable.
			///
			/// The list represents each key-value pair in the Fields. Keys
			/// which have multiple values are represented by multiple entries in this
			/// list with the same key.
			///
			/// The tuple is a pair of the field key, represented as a string, and
			/// Value, represented as a list of bytes. In a valid Fields, all keys
			/// and values are valid UTF-8 strings. However, values are not always
			/// well-formed, so they are represented as a raw list of bytes.
			///
			/// An error result will be returned if any header or value was
			/// syntactically invalid, or if a header was forbidden.
			from-list: static func(entries: list<tuple<field-key, field-value>>) -> result<fields, header-error>;
		}

		/// Headers is an alias for Fields.
		type headers = fields;

		/// Trailers is an alias for Fields.
		type trailers = fields;

		/// Represents an incoming HTTP Request.
		resource incoming-request {

			/// Returns the authority from the request, if it was present.
			authority: func() -> option<string>;

			/// Gives the `incoming-body` associated with this request. Will only
			/// return success at most once, and subsequent calls will return error.
			consume: func() -> result<incoming-body>;

			/// Get the `headers` associated with the request.
			///
			/// The returned `headers` resource is immutable: `set`, `append`, and
			/// `delete` operations will fail with `header-error.immutable`.
			///
			/// The `headers` returned are a child resource: it must be dropped before
			/// the parent `incoming-request` is dropped. Dropping this
			/// `incoming-request` before all children are dropped will trap.
			headers: func() -> headers;

			/// Returns the method of the incoming request.
			method: func() -> method;

			/// Returns the path with query parameters from the request, as a string.
			path-with-query: func() -> option<string>;

			/// Returns the protocol scheme from the request.
			scheme: func() -> option<scheme>;
		}

		/// Represents an outgoing HTTP Request.
		resource outgoing-request {
			/// Construct a new `outgoing-request` with a default `method` of `GET`, and
			/// `none` values for `path-with-query`, `scheme`, and `authority`.
			///
			/// * `headers` is the HTTP Headers for the Request.
			///
			/// It is possible to construct, or manipulate with the accessor functions
			/// below, an `outgoing-request` with an invalid combination of `scheme`
			/// and `authority`, or `headers` which are not permitted to be sent.
			/// It is the obligation of the `outgoing-handler.handle` implementation
			/// to reject invalid constructions of `outgoing-request`.
			constructor(headers: headers);

			/// Get the HTTP Authority for the Request. A value of `none` may be used
			/// with Related Schemes which do not require an Authority. The HTTP and
			/// HTTPS schemes always require an authority.
			authority: func() -> option<string>;

			/// Returns the resource corresponding to the outgoing Body for this
			/// Request.
			///
			/// Returns success on the first call: the `outgoing-body` resource for
			/// this `outgoing-request` can be retrieved at most once. Subsequent
			/// calls will return error.
			body: func() -> result<outgoing-body>;

			/// Get the headers associated with the Request.
			///
			/// The returned `headers` resource is immutable: `set`, `append`, and
			/// `delete` operations will fail with `header-error.immutable`.
			///
			/// This headers resource is a child: it must be dropped before the parent
			/// `outgoing-request` is dropped, or its ownership is transfered to
			/// another component by e.g. `outgoing-handler.handle`.
			headers: func() -> headers;

			/// Get the Method for the Request.
			method: func() -> method;

			/// Get the combination of the HTTP Path and Query for the Request.
			/// When `none`, this represents an empty Path and empty Query.
			path-with-query: func() -> option<string>;

			/// Get the HTTP Related Scheme for the Request. When `none`, the
			/// implementation may choose an appropriate default scheme.
			scheme: func() -> option<scheme>;

			/// Set the HTTP Authority for the Request. A value of `none` may be used
			/// with Related Schemes which do not require an Authority. The HTTP and
			/// HTTPS schemes always require an authority. Fails if the string given is
			/// not a syntactically valid uri authority.
			set-authority: func(authority: option<string>) -> result;

			/// Set the Method for the Request. Fails if the string present in a
			/// `method.other` argument is not a syntactically valid method.
			set-method: func(method: method) -> result;

			/// Set the combination of the HTTP Path and Query for the Request.
			/// When `none`, this represents an empty Path and empty Query. Fails is the
			/// string given is not a syntactically valid path and query uri component.
			set-path-with-query: func(path-with-query: option<string>) -> result;

			/// Set the HTTP Related Scheme for the Request. When `none`, the
			/// implementation may choose an appropriate default scheme. Fails if the
			/// string given is not a syntactically valid uri scheme.
			set-scheme: func(scheme: option<scheme>) -> result;
		}

		/// Parameters for making an HTTP Request. Each of these parameters is
		/// currently an optional timeout applicable to the transport layer of the
		/// HTTP protocol.
		///
		/// These timeouts are separate from any the user may use to bound a
		/// blocking call to `wasi:io/poll.poll`.
		resource request-options {
			/// Construct a default `request-options` value.
			constructor();

			/// The timeout for receiving subsequent chunks of bytes in the Response
			/// body stream.
			between-bytes-timeout: func() -> option<duration>;

			/// The timeout for the initial connect to the HTTP Server.
			connect-timeout: func() -> option<duration>;

			/// The timeout for receiving the first byte of the Response body.
			first-byte-timeout: func() -> option<duration>;

			/// Set the timeout for receiving subsequent chunks of bytes in the Response
			/// body stream. An error return value indicates that this timeout is not
			/// supported.
			set-between-bytes-timeout: func(duration: option<duration>) -> result;

			/// Set the timeout for the initial connect to the HTTP Server. An error
			/// return value indicates that this timeout is not supported.
			set-connect-timeout: func(duration: option<duration>) -> result;

			/// Set the timeout for receiving the first byte of the Response body. An
			/// error return value indicates that this timeout is not supported.
			set-first-byte-timeout: func(duration: option<duration>) -> result;
		}

		/// Represents the ability to send an HTTP Response.
		///
		/// This resource is used by the `wasi:http/incoming-handler` interface to
		/// allow a Response to be sent corresponding to the Request provided as the
		/// other argument to `incoming-handler.handle`.
		resource response-outparam {

			/// Set the value of the `response-outparam` to either send a response,
			/// or indicate an error.
			///
			/// This method consumes the `response-outparam` to ensure that it is
			/// called at most once. If it is never called, the implementation
			/// will respond with an error.
			///
			/// The user may provide an `error` to `response` to allow the
			/// implementation determine how to respond with an HTTP error response.
			set: static func(param: response-outparam, response: result<outgoing-response, error-code>);
		}

		/// This type corresponds to the HTTP standard Status Code.
		type status-code = u16;

		/// Represents an incoming HTTP Response.
		resource incoming-response {

			/// Returns the incoming body. May be called at most once. Returns error
			/// if called additional times.
			consume: func() -> result<incoming-body>;

			/// Returns the headers from the incoming response.
			///
			/// The returned `headers` resource is immutable: `set`, `append`, and
			/// `delete` operations will fail with `header-error.immutable`.
			///
			/// This headers resource is a child: it must be dropped before the parent
			/// `incoming-response` is dropped.
			headers: func() -> headers;

			/// Returns the status code from the incoming response.
			status: func() -> status-code;
		}

		/// Represents an incoming HTTP Request or Response's Body.
		///
		/// A body has both its contents - a stream of bytes - and a (possibly
		/// empty) set of trailers, indicating that the full contents of the
		/// body have been received. This resource represents the contents as
		/// an `input-stream` and the delivery of trailers as a `future-trailers`,
		/// and ensures that the user of this interface may only be consuming either
		/// the body contents or waiting on trailers at any given time.
		resource incoming-body {

			/// Returns the contents of the body, as a stream of bytes.
			///
			/// Returns success on first call: the stream representing the contents
			/// can be retrieved at most once. Subsequent calls will return error.
			///
			/// The returned `input-stream` resource is a child: it must be dropped
			/// before the parent `incoming-body` is dropped, or consumed by
			/// `incoming-body.finish`.
			///
			/// This invariant ensures that the implementation can determine whether
			/// the user is consuming the contents of the body, waiting on the
			/// `future-trailers` to be ready, or neither. This allows for network
			/// backpressure is to be applied when the user is consuming the body,
			/// and for that backpressure to not inhibit delivery of the trailers if
			/// the user does not read the entire body.
			%stream: func() -> result<input-stream>;

			/// Takes ownership of `incoming-body`, and returns a `future-trailers`.
			/// This function will trap if the `input-stream` child is still alive.
			finish: static func(this: incoming-body) -> future-trailers;
		}

		/// Represents a future which may eventaully return trailers, or an error.
		///
		/// In the case that the incoming HTTP Request or Response did not have any
		/// trailers, this future will resolve to the empty set of trailers once the
		/// complete Request or Response body has been received.
		resource future-trailers {

			/// Returns the contents of the trailers, or an error which occured,
			/// once the future is ready.
			///
			/// The outer `option` represents future readiness. Users can wait on this
			/// `option` to become `some` using the `subscribe` method.
			///
			/// The outer `result` is used to retrieve the trailers or error at most
			/// once. It will be success on the first call in which the outer option
			/// is `some`, and error on subsequent calls.
			///
			/// The inner `result` represents that either the HTTP Request or Response
			/// body, as well as any trailers, were received successfully, or that an
			/// error occured receiving them. The optional `trailers` indicates whether
			/// or not trailers were present in the body.
			///
			/// When some `trailers` are returned by this method, the `trailers`
			/// resource is immutable, and a child. Use of the `set`, `append`, or
			/// `delete` methods will return an error, and the resource must be
			/// dropped before the parent `future-trailers` is dropped.
			get: func() -> option<result<result<option<trailers>, error-code>>>;

			/// Returns a pollable which becomes ready when either the trailers have
			/// been received, or an error has occured. When this pollable is ready,
			/// the `get` method will return `some`.
			subscribe: func() -> pollable;
		}

		/// Represents an outgoing HTTP Response.
		resource outgoing-response {
			/// Construct an `outgoing-response`, with a default `status-code` of `200`.
			/// If a different `status-code` is needed, it must be set via the
			/// `set-status-code` method.
			///
			/// * `headers` is the HTTP Headers for the Response.
			constructor(headers: headers);

			/// Returns the resource corresponding to the outgoing Body for this Response.
			///
			/// Returns success on the first call: the `outgoing-body` resource for
			/// this `outgoing-response` can be retrieved at most once. Subsequent
			/// calls will return error.
			body: func() -> result<outgoing-body>;

			/// Get the headers associated with the Request.
			///
			/// The returned `headers` resource is immutable: `set`, `append`, and
			/// `delete` operations will fail with `header-error.immutable`.
			///
			/// This headers resource is a child: it must be dropped before the parent
			/// `outgoing-request` is dropped, or its ownership is transfered to
			/// another component by e.g. `outgoing-handler.handle`.
			headers: func() -> headers;

			/// Set the HTTP Status Code for the Response. Fails if the status-code
			/// given is not a valid http status code.
			set-status-code: func(status-code: status-code) -> result;

			/// Get the HTTP Status Code for the Response.
			status-code: func() -> status-code;
		}

		/// Represents an outgoing HTTP Request or Response's Body.
		///
		/// A body has both its contents - a stream of bytes - and a (possibly
		/// empty) set of trailers, inducating the full contents of the body
		/// have been sent. This resource represents the contents as an
		/// `output-stream` child resource, and the completion of the body (with
		/// optional trailers) with a static function that consumes the
		/// `outgoing-body` resource, and ensures that the user of this interface
		/// may not write to the body contents after the body has been finished.
		///
		/// If the user code drops this resource, as opposed to calling the static
		/// method `finish`, the implementation should treat the body as incomplete,
		/// and that an error has occured. The implementation should propogate this
		/// error to the HTTP protocol by whatever means it has available,
		/// including: corrupting the body on the wire, aborting the associated
		/// Request, or sending a late status code for the Response.
		resource outgoing-body {

			/// Returns a stream for writing the body contents.
			///
			/// The returned `output-stream` is a child resource: it must be dropped
			/// before the parent `outgoing-body` resource is dropped (or finished),
			/// otherwise the `outgoing-body` drop or `finish` will trap.
			///
			/// Returns success on the first call: the `output-stream` resource for
			/// this `outgoing-body` may be retrieved at most once. Subsequent calls
			/// will return error.
			write: func() -> result<output-stream>;

			/// Finalize an outgoing body, optionally providing trailers. This must be
			/// called to signal that the response is complete. If the `outgoing-body`
			/// is dropped without calling `outgoing-body.finalize`, the implementation
			/// should treat the body as corrupted.
			///
			/// Fails if the body's `outgoing-request` or `outgoing-response` was
			/// constructed with a Content-Length header, and the contents written
			/// to the body (via `write`) does not match the value given in the
			/// Content-Length.
			finish: static func(this: outgoing-body, trailers: option<trailers>) -> result<_, error-code>;
		}

		/// Represents a future which may eventaully return an incoming HTTP
		/// Response, or an error.
		///
		/// This resource is returned by the `wasi:http/outgoing-handler` interface to
		/// provide the HTTP Response corresponding to the sent Request.
		resource future-incoming-response {

			/// Returns the incoming HTTP Response, or an error, once one is ready.
			///
			/// The outer `option` represents future readiness. Users can wait on this
			/// `option` to become `some` using the `subscribe` method.
			///
			/// The outer `result` is used to retrieve the response or error at most
			/// once. It will be success on the first call in which the outer option
			/// is `some`, and error on subsequent calls.
			///
			/// The inner `result` represents that either the incoming HTTP Response
			/// status and headers have recieved successfully, or that an error
			/// occured. Errors may also occur while consuming the response body,
			/// but those will be reported by the `incoming-body` and its
			/// `output-stream` child.
			get: func() -> option<result<result<incoming-response, error-code>>>;

			/// Returns a pollable which becomes ready when either the Response has
			/// been received, or an error has occured. When this pollable is ready,
			/// the `get` method will return `some`.
			subscribe: func() -> pollable;
		}

		/// Attempts to extract a http-related `error` from the wasi:io `error`
		/// provided.
		///
		/// Stream operations which return
		/// `wasi:io/stream/stream-error::last-operation-failed` have a payload of
		/// type `wasi:io/error/error` with more information about the operation
		/// that failed. This payload can be passed through to this function to see
		/// if there's http-related information about the error to return.
		///
		/// Note that this function is fallible because not all io-errors are
		/// http-related errors.
		http-error-code: func(err: borrow<io-error>) -> option<error-code>;
	}

	/// This interface defines a handler of incoming HTTP Requests. It should
	/// be exported by components which can respond to HTTP Requests.
	interface incoming-handler {
		use types.{incoming-request};
		use types.{response-outparam};

		/// This function is invoked with an incoming HTTP Request, and a resource
		/// `response-outparam` which provides the capability to reply with an HTTP
		/// Response. The response is sent by calling the `response-outparam.set`
		/// method, which allows execution to continue after the response has been
		/// sent. This enables both streaming to the response body, and performing other
		/// work.
		///
		/// The implementor of this function must write a response to the
		/// `response-outparam` before returning, or else the caller will respond
		/// with an error on its behalf.
		handle: func(request: incoming-request, response-out: response-outparam);
	}

	/// This interface defines a handler of outgoing HTTP Requests. It should be
	/// imported by components which wish to make HTTP Requests.
	interface outgoing-handler {
		use types.{outgoing-request};
		use types.{request-options};
		use types.{future-incoming-response};
		use types.{error-code};

		/// This function is invoked with an outgoing HTTP Request, and it returns
		/// a resource `future-incoming-response` which represents an HTTP Response
		/// which may arrive in the future.
		///
		/// The `options` argument accepts optional parameters for the HTTP
		/// protocol's transport layer.
		///
		/// This function may return an error if the `outgoing-request` is invalid
		/// or not allowed to be made. Otherwise, protocol errors are reported
		/// through the `future-incoming-response`.
		handle: func(request: outgoing-request, options: option<request-options>) -> result<future-incoming-response, error-code>;
	}
}

package wasi:clocks@0.2.0 {
	/// WASI Monotonic Clock is a clock API intended to let users measure elapsed
	/// time.
	///
	/// It is intended to be portable at least between Unix-family platforms and
	/// Windows.
	///
	/// A monotonic clock is a clock which has an unspecified initial value, and
	/// successive reads of the clock will produce non-decreasing values.
	///
	/// It is intended for measuring elapsed time.
	interface monotonic-clock {
		use wasi:io/poll@0.2.0.{pollable};

		/// An instant in time, in nanoseconds. An instant is relative to an
		/// unspecified initial value, and can only be compared to instances from
		/// the same monotonic-clock.
		type instant = u64;

		/// A duration of time, in nanoseconds.
		type duration = u64;

		/// Read the current value of the clock.
		///
		/// The clock is monotonic, therefore calling this function repeatedly will
		/// produce a sequence of non-decreasing values.
		now: func() -> instant;

		/// Query the resolution of the clock. Returns the duration of time
		/// corresponding to a clock tick.
		resolution: func() -> duration;

		/// Create a `pollable` which will resolve once the specified instant
		/// occured.
		subscribe-instant: func(when: instant) -> pollable;

		/// Create a `pollable` which will resolve once the given duration has
		/// elapsed, starting at the time at which this function was called.
		/// occured.
		subscribe-duration: func(when: duration) -> pollable;
	}

	/// WASI Wall Clock is a clock API intended to let users query the current
	/// time. The name "wall" makes an analogy to a "clock on the wall", which
	/// is not necessarily monotonic as it may be reset.
	///
	/// It is intended to be portable at least between Unix-family platforms and
	/// Windows.
	///
	/// A wall clock is a clock which measures the date and time according to
	/// some external reference.
	///
	/// External references may be reset, so this clock is not necessarily
	/// monotonic, making it unsuitable for measuring elapsed time.
	///
	/// It is intended for reporting the current date and time for humans.
	interface wall-clock {
		/// A time and date in seconds plus nanoseconds.
		record datetime {
			seconds: u64,
			nanoseconds: u32,
		}

		/// Read the current value of the clock.
		///
		/// This clock is not monotonic, therefore calling this function repeatedly
		/// will not necessarily produce a sequence of non-decreasing values.
		///
		/// The returned timestamps represent the number of seconds since
		/// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
		/// also known as [Unix Time].
		///
		/// The nanoseconds field of the output is always less than 1000000000.
		///
		/// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
		/// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
		now: func() -> datetime;

		/// Query the resolution of the clock.
		///
		/// The nanoseconds field of the output is always less than 1000000000.
		resolution: func() -> datetime;
	}
}

package wasi:io@0.2.0 {
	interface error {
		/// A resource which represents some error information.
		///
		/// The only method provided by this resource is `to-debug-string`,
		/// which provides some human-readable information about the error.
		///
		/// In the `wasi:io` package, this resource is returned through the
		/// `wasi:io/streams/stream-error` type.
		///
		/// To provide more specific error information, other interfaces may
		/// provide functions to further "downcast" this error into more specific
		/// error information. For example, `error`s returned in streams derived
		/// from filesystem types to be described using the filesystem's own
		/// error-code type, using the function
		/// `wasi:filesystem/types/filesystem-error-code`, which takes a parameter
		/// `borrow<error>` and returns
		/// `option<wasi:filesystem/types/error-code>`.
		///
		/// The set of functions which can "downcast" an `error` into a more
		/// concrete type is open.
		resource error {

			/// Returns a string that is suitable to assist humans in debugging
			/// this error.
			///
			/// WARNING: The returned string should not be consumed mechanically!
			/// It may change across platforms, hosts, or other implementation
			/// details. Parsing this string is a major platform-compatibility
			/// hazard.
			to-debug-string: func() -> string;
		}
	}

	/// A poll API intended to let users wait for I/O events on multiple handles
	/// at once.
	interface poll {
		/// `pollable` represents a single I/O event which may be ready, or not.
		resource pollable {

			/// `block` returns immediately if the pollable is ready, and otherwise
			/// blocks until ready.
			///
			/// This function is equivalent to calling `poll.poll` on a list
			/// containing only this pollable.
			block: func();

			/// Return the readiness of a pollable. This function never blocks.
			///
			/// Returns `true` when the pollable is ready, and `false` otherwise.
			ready: func() -> bool;
		}

		/// Poll for completion on a set of pollables.
		///
		/// This function takes a list of pollables, which identify I/O sources of
		/// interest, and waits until one or more of the events is ready for I/O.
		///
		/// The result `list<u32>` contains one or more indices of handles in the
		/// argument list that is ready for I/O.
		///
		/// If the list contains more elements than can be indexed with a `u32`
		/// value, this function traps.
		///
		/// A timeout can be implemented by adding a pollable from the
		/// wasi-clocks API to the list.
		///
		/// This function does not return a `result`; polling in itself does not
		/// do any I/O so it doesn't fail. If any of the I/O sources identified by
		/// the pollables has an error, it is indicated by marking the source as
		/// being reaedy for I/O.
		poll: func(in: list<borrow<pollable>>) -> list<u32>;
	}

	/// WASI I/O is an I/O abstraction API which is currently focused on providing
	/// stream types.
	///
	/// In the future, the component model is expected to add built-in stream types;
	/// when it does, they are expected to subsume this API.
	interface streams {
		use error.{error};
		use poll.{pollable};

		/// An error for input-stream and output-stream operations.
		variant stream-error {
			/// The last operation (a write or flush) failed before completion.
			///
			/// More information is available in the `error` payload.
			last-operation-failed(error),
			/// The stream is closed: no more input will be accepted by the
			/// stream. A closed output-stream will return this error on all
			/// future operations.
			closed,
		}

		/// An input bytestream.
		///
		/// `input-stream`s are *non-blocking* to the extent practical on underlying
		/// platforms. I/O operations always return promptly; if fewer bytes are
		/// promptly available than requested, they return the number of bytes promptly
		/// available, which could even be zero. To wait for data to be available,
		/// use the `subscribe` function to obtain a `pollable` which can be polled
		/// for using `wasi:io/poll`.
		resource input-stream {

			/// Read bytes from a stream, after blocking until at least one byte can
			/// be read. Except for blocking, behavior is identical to `read`.
			blocking-read: func(len: u64) -> result<list<u8>, stream-error>;

			/// Skip bytes from a stream, after blocking until at least one byte
			/// can be skipped. Except for blocking behavior, identical to `skip`.
			blocking-skip: func(len: u64) -> result<u64, stream-error>;

			/// Perform a non-blocking read from the stream.
			///
			/// When the source of a `read` is binary data, the bytes from the source
			/// are returned verbatim. When the source of a `read` is known to the
			/// implementation to be text, bytes containing the UTF-8 encoding of the
			/// text are returned.
			///
			/// This function returns a list of bytes containing the read data,
			/// when successful. The returned list will contain up to `len` bytes;
			/// it may return fewer than requested, but not more. The list is
			/// empty when no bytes are available for reading at this time. The
			/// pollable given by `subscribe` will be ready when more bytes are
			/// available.
			///
			/// This function fails with a `stream-error` when the operation
			/// encounters an error, giving `last-operation-failed`, or when the
			/// stream is closed, giving `closed`.
			///
			/// When the caller gives a `len` of 0, it represents a request to
			/// read 0 bytes. If the stream is still open, this call should
			/// succeed and return an empty list, or otherwise fail with `closed`.
			///
			/// The `len` parameter is a `u64`, which could represent a list of u8 which
			/// is not possible to allocate in wasm32, or not desirable to allocate as
			/// as a return value by the callee. The callee may return a list of bytes
			/// less than `len` in size while more bytes are available for reading.
			read: func(len: u64) -> result<list<u8>, stream-error>;

			/// Skip bytes from a stream. Returns number of bytes skipped.
			///
			/// Behaves identical to `read`, except instead of returning a list
			/// of bytes, returns the number of bytes consumed from the stream.
			skip: func(len: u64) -> result<u64, stream-error>;

			/// Create a `pollable` which will resolve once either the specified stream
			/// has bytes available to read or the other end of the stream has been
			/// closed.
			/// The created `pollable` is a child resource of the `input-stream`.
			/// Implementations may trap if the `input-stream` is dropped before
			/// all derived `pollable`s created with this function are dropped.
			subscribe: func() -> pollable;
		}

		/// An output bytestream.
		///
		/// `output-stream`s are *non-blocking* to the extent practical on
		/// underlying platforms. Except where specified otherwise, I/O operations also
		/// always return promptly, after the number of bytes that can be written
		/// promptly, which could even be zero. To wait for the stream to be ready to
		/// accept data, the `subscribe` function to obtain a `pollable` which can be
		/// polled for using `wasi:io/poll`.
		resource output-stream {

			/// Request to flush buffered output, and block until flush completes
			/// and stream is ready for writing again.
			blocking-flush: func() -> result<_, stream-error>;

			/// Read from one stream and write to another, with blocking.
			///
			/// This is similar to `splice`, except that it blocks until the
			/// `output-stream` is ready for writing, and the `input-stream`
			/// is ready for reading, before performing the `splice`.
			blocking-splice: func(src: borrow<input-stream>, len: u64) -> result<u64, stream-error>;

			/// Perform a write of up to 4096 bytes, and then flush the stream. Block
			/// until all of these operations are complete, or an error occurs.
			///
			/// This is a convenience wrapper around the use of `check-write`,
			/// `subscribe`, `write`, and `flush`, and is implemented with the
			/// following pseudo-code:
			///
			/// ```text
			/// let pollable = this.subscribe();
			/// while !contents.is_empty() {
			/// // Wait for the stream to become writable
			/// pollable.block();
			/// let Ok(n) = this.check-write(); // eliding error handling
			/// let len = min(n, contents.len());
			/// let (chunk, rest) = contents.split_at(len);
			/// this.write(chunk  );            // eliding error handling
			/// contents = rest;
			/// }
			/// this.flush();
			/// // Wait for completion of `flush`
			/// pollable.block();
			/// // Check for any errors that arose during `flush`
			/// let _ = this.check-write();         // eliding error handling
			/// ```
			blocking-write-and-flush: func(contents: list<u8>) -> result<_, stream-error>;

			/// Perform a write of up to 4096 zeroes, and then flush the stream.
			/// Block until all of these operations are complete, or an error
			/// occurs.
			///
			/// This is a convenience wrapper around the use of `check-write`,
			/// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
			/// the following pseudo-code:
			///
			/// ```text
			/// let pollable = this.subscribe();
			/// while num_zeroes != 0 {
			/// // Wait for the stream to become writable
			/// pollable.block();
			/// let Ok(n) = this.check-write(); // eliding error handling
			/// let len = min(n, num_zeroes);
			/// this.write-zeroes(len);         // eliding error handling
			/// num_zeroes -= len;
			/// }
			/// this.flush();
			/// // Wait for completion of `flush`
			/// pollable.block();
			/// // Check for any errors that arose during `flush`
			/// let _ = this.check-write();         // eliding error handling
			/// ```
			blocking-write-zeroes-and-flush: func(len: u64) -> result<_, stream-error>;

			/// Check readiness for writing. This function never blocks.
			///
			/// Returns the number of bytes permitted for the next call to `write`,
			/// or an error. Calling `write` with more bytes than this function has
			/// permitted will trap.
			///
			/// When this function returns 0 bytes, the `subscribe` pollable will
			/// become ready when this function will report at least 1 byte, or an
			/// error.
			check-write: func() -> result<u64, stream-error>;

			/// Request to flush buffered output. This function never blocks.
			///
			/// This tells the output-stream that the caller intends any buffered
			/// output to be flushed. the output which is expected to be flushed
			/// is all that has been passed to `write` prior to this call.
			///
			/// Upon calling this function, the `output-stream` will not accept any
			/// writes (`check-write` will return `ok(0)`) until the flush has
			/// completed. The `subscribe` pollable will become ready when the
			/// flush has completed and the stream can accept more writes.
			flush: func() -> result<_, stream-error>;

			/// Read from one stream and write to another.
			///
			/// The behavior of splice is equivelant to:
			/// 1. calling `check-write` on the `output-stream`
			/// 2. calling `read` on the `input-stream` with the smaller of the
			/// `check-write` permitted length and the `len` provided to `splice`
			/// 3. calling `write` on the `output-stream` with that read data.
			///
			/// Any error reported by the call to `check-write`, `read`, or
			/// `write` ends the splice and reports that error.
			///
			/// This function returns the number of bytes transferred; it may be less
			/// than `len`.
			splice: func(src: borrow<input-stream>, len: u64) -> result<u64, stream-error>;

			/// Create a `pollable` which will resolve once the output-stream
			/// is ready for more writing, or an error has occured. When this
			/// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
			/// error.
			///
			/// If the stream is closed, this pollable is always ready immediately.
			///
			/// The created `pollable` is a child resource of the `output-stream`.
			/// Implementations may trap if the `output-stream` is dropped before
			/// all derived `pollable`s created with this function are dropped.
			subscribe: func() -> pollable;

			/// Perform a write. This function never blocks.
			///
			/// When the destination of a `write` is binary data, the bytes from
			/// `contents` are written verbatim. When the destination of a `write` is
			/// known to the implementation to be text, the bytes of `contents` are
			/// transcoded from UTF-8 into the encoding of the destination and then
			/// written.
			///
			/// Precondition: check-write gave permit of Ok(n) and contents has a
			/// length of less than or equal to n. Otherwise, this function will trap.
			///
			/// returns Err(closed) without writing if the stream has closed since
			/// the last call to check-write provided a permit.
			write: func(contents: list<u8>) -> result<_, stream-error>;

			/// Write zeroes to a stream.
			///
			/// This should be used precisely like `write` with the exact same
			/// preconditions (must use check-write first), but instead of
			/// passing a list of bytes, you simply pass the number of zero-bytes
			/// that should be written.
			write-zeroes: func(len: u64) -> result<_, stream-error>;
		}
	}
}

package wasi:random@0.2.0 {
	/// WASI Random is a random data API.
	///
	/// It is intended to be portable at least between Unix-family platforms and
	/// Windows.
	interface random {
		/// Return `len` cryptographically-secure random or pseudo-random bytes.
		///
		/// This function must produce data at least as cryptographically secure and
		/// fast as an adequately seeded cryptographically-secure pseudo-random
		/// number generator (CSPRNG). It must not block, from the perspective of
		/// the calling program, under any circumstances, including on the first
		/// request and on requests for numbers of bytes. The returned data must
		/// always be unpredictable.
		///
		/// This function must always return fresh data. Deterministic environments
		/// must omit this function, rather than implementing it with deterministic
		/// data.
		get-random-bytes: func(len: u64) -> list<u8>;

		/// Return a cryptographically-secure random or pseudo-random `u64` value.
		///
		/// This function returns the same type of data as `get-random-bytes`,
		/// represented as a `u64`.
		get-random-u64: func() -> u64;
	}
}
